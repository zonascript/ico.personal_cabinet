<?php
namespace Xcart;

use Xcart\App\Helpers\ClassNames;
use Xcart\App\Helpers\SmartProperties;
use Xcart\App\Orm\AutoMetaModel;
use Xcart\App\Orm\Legacy\OrmLegacy;

class Data extends OrmLegacy
{
    use ClassNames, SmartProperties;

    protected static $sql_tbl = [];
    protected $aPrimaryKeys = [];
    protected $aPrimaryKeysValues = [];
    protected $aPrimaryTableValue;
    protected $sPrimaryTable;

    /**
     * classData constructor.
     * @param array $aParams
     * @throws \Exception
     */
    public function __construct($aParams = [])
    {
        if (empty(self::$sql_tbl)) {
            global $sql_tbl;
            self::$sql_tbl = $sql_tbl;
        }

        if (!empty($aParams)) {
            if (!is_array($aParams))
                throw new \Exception('Parameter must be an array');
            $this->aPrimaryKeysValues = array_intersect_key($aParams, array_flip($this->aPrimaryKeys));
            $this->fillPrimaryTableInfo();
        }
    }

    public function getTableName()
    {
        //@TODO: Переделать. Нужно что-бы возвращалось или имя или шаблон для подстановки префикса пример xcart_orders или {orders}
        return self::$sql_tbl[$this->sPrimaryTable];
    }

    public function __smartGet($name)
    {
        $method = 'get' . ucfirst($name);
        if (method_exists($this, $method)) {
            return $this->$method();
        }  elseif (property_exists($this, $name)) {
            return $this->{$name};
        }
        else {
            return $this->getField($name);
        }
    }

    public function __smartSet($name, $value)
    {
        $method = 'set' . ucfirst($name);
        if (method_exists($this, $method)) {
            return $this->$method($value);
        } elseif (property_exists($this, $name)) {
            $this->{$name} = $value;
            return true;
        }
        else {
            return $this->setField($name, $value);
        }
    }

    public function __smartIsset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        }
        else {
            return isset($this->aPrimaryTableValue[$name]);
        }

    }

    public function __call($method, $args)
    {
        return parent::__call($method, $args); // TODO: Change the autogenerated stub
    }

    public static function __callStatic($method, $args)
    {
        return parent::__callStatic($method, $args); // TODO: Change the autogenerated stub
    }

    public function getPrimaryKey()
    {
        return $this->aPrimaryKeys;
    }

    public static function getPrimaryKeyName($asArray = false)
    {
        return (new static())->getPrimaryKey();
    }

    /**
     * @return static
     */
    protected function _clone()
    {
        return clone $this;
    }

    public function _insert($is_replace = false)
    {
        return func_array2insert($this->sPrimaryTable, $this->aPrimaryTableValue, $is_replace);
    }

    public function _delete()
    {
        if (!empty($this->aPrimaryKeysValues)) {
            db_query("DELETE FROM " . self::$sql_tbl[$this->sPrimaryTable] . " WHERE " . $this->getWhereClause());
        }
    }

    public function _refresh()
    {
        $this->fillPrimaryTableInfo();
    }

    protected function recursive_escape(&$item)
    {
        $item = addslashes($item);
    }

    public function _update()
    {
        $aUpdateValues = $this->aPrimaryTableValue;
        array_walk_recursive($aUpdateValues, array(__CLASS__, 'recursive_escape'));
        func_array2update($this->sPrimaryTable, $aUpdateValues, $this->getWhereClause());
    }


    public function _save($is_replace = false)
    {
        if (empty($this->aPrimaryKeysValues)) {
            $this->_insert($is_replace);
        } else {
            $this->_update();
        }
    }

    protected function fillPrimaryTableInfo()
    {
        if (!empty($this->aPrimaryKeysValues)) {
            $this->aPrimaryTableValue = func_query_first("SELECT * FROM " . self::$sql_tbl[$this->sPrimaryTable] . " WHERE " . $this->getWhereClause());
        }
    }

    public function setAttributes($attributes)
    {
        return $this->fill($attributes);
    }

    public function fill($aValues)
    {
        if (!empty($aValues)) {
            $this->aPrimaryTableValue = $aValues;
            $this->aPrimaryKeysValues = array_intersect_key($aValues, array_flip($this->aPrimaryKeys));
        }
        return $this;
    }

    /**
     * @param string $sFieldName
     * @return mixed|array
     */
    public function getField($sFieldName = null)
    {
        $res = null;
        if (empty($sFieldName)) {
            $res = $this->getFields();
        } else if (isset($this->aPrimaryTableValue[$sFieldName])) {
            $res = $this->aPrimaryTableValue[$sFieldName];
        }
        return $res;
    }

    /**
     * Вместо getFields в Model
     * @return array
     */
    public static function getColumns()
    {
        return [];
    }

    public function getFields($aFields = array())
    {

        if (is_array($aFields)) {
            if (!isset($this)) { //@TODO: static
                return static::getColumns();
            }
            if (empty($aFields)) {
                return $this->aPrimaryTableValue;
            }

            return array_intersect_key($this->aPrimaryTableValue, array_flip($aFields));
        }
        else {
            return $this->aPrimaryTableValue;
        }
    }

    public function setField($sFieldName, $sNewValue)
    {
        $this->aPrimaryTableValue[$sFieldName] = $sNewValue;

        if (in_array($sFieldName, $this->aPrimaryKeys))
            $this->aPrimaryKeysValues[$sFieldName] = $sNewValue;
        return $this;
    }

    public function setFields($aFieldNamesValues)
    {
        foreach ($aFieldNamesValues as $key => $value)
            $this->setField($key, $value);
        return $this;
    }

    public function updateField($sFieldName, $sNewValue)
    {

        $aToUpdate[$sFieldName] = $sNewValue;
        if (empty($this->aPrimaryKeysValues))
            throw new \Exception('Empty primary keys values for update field');
        $aKeyArray = $this->aPrimaryKeysValues;
        array_walk($aKeyArray, function (&$a, $b) {
            $a = $b . ' = "' . $a . '"';
        });
        func_array2update($this->sPrimaryTable, $aToUpdate, $this->getWhereClause());
        $this->setField($sFieldName, $sNewValue);
        return $this;
    }

    public function updateFields($aFieldNamesValues = [])
    {
        if (!empty($aFieldNamesValues)) {
            if (empty($this->aPrimaryKeysValues))
                throw new \Exception('Empty primary keys values for update fields');
            func_array2update($this->sPrimaryTable, $aFieldNamesValues, $this->getWhereClause());
            $this->setFields($aFieldNamesValues);
        }
        return $this;
    }

    protected function getWhereClause()
    {
        $aKeyArray = $this->aPrimaryKeysValues;
        array_walk($aKeyArray, function (&$a, $b) {
            $a = $b . ' = "' . $a . '"';
        });
        return implode(" AND ", $aKeyArray);
    }

    /**
     * @return static
     */
    public static function model($aParams = [])
    {
        $class = get_called_class();
        return new $class($aParams);
    }

    /**
     * @return static[]
     */
    public function findAll(SQLBuilder $oSQL)
    {
        $aSearchResult = null;
        $aResult = $oSQL->setSelect('main.*')->setFromTable($this->sPrimaryTable, 'main')->query()->getQueryResult();
        if (!empty($aResult)) {
            foreach ($aResult as $aReturnResult) {
                $aSearchResult[] = $this::model()->fill($aReturnResult);
            }
        }
        return $aSearchResult;
    }

    /**
     * @return static
     */
    public function find(SQLBuilder $oSQL)
    {
        $oSearchResult = $this::model();
        $aResult = $oSQL->setSelect('main.*')->setFromTable($this->sPrimaryTable, 'main')->query_first()->getQueryResult();
        if (!empty($aResult)) $oSearchResult->fill($aResult);
        return $oSearchResult;
    }

    public function getCache()
    {
        return false;
    }

    public function noCache()
    {
        return false;
    }
}